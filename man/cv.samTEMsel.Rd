% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/samTEMsel.main.R
\name{cv.samTEMsel}
\alias{cv.samTEMsel}
\title{Sparse Additive Models for Treatment Effect-Modifier Selection (cross-validation function)}
\usage{
cv.samTEMsel(y, A, X, mu.hat = NULL, d = 3, n.folds = 10,
  nlambda = 50, lambda.min.ratio = 0.01, thol = 1e-05,
  max.ite = 1e+05, regfunc = "L1", row.ordering = NULL,
  cv1sd = FALSE, terms.fit = FALSE, plots = TRUE)
}
\arguments{
\item{y}{a n-by-1 vector of responses}

\item{A}{a n-by-1 vector of treatment variable; each element represents one of the L(>1) treatment conditions; e.g., c(1,2,1,1,3...); can be a factor-valued}

\item{X}{a n-by-p matrix of pretreatment features}

\item{mu.hat}{a n-by-1 vector of the fitted X main effect term of the model provided by the user; defult is \code{NULL}, in which case \code{mu.hat} is taken to be a vector of zeros; the optimal choice for this vector is E(y|X)}

\item{d}{number of basis spline functions to be used for each component function; the default value is 3; d=1 corresponds to the linear model}

\item{n.folds}{number of folds for cross-validation; the default is 10.}

\item{nlambda}{total number of lambda values; the default value is 50.}

\item{lambda.min.ratio}{the smallest value for lambda, as a fraction of lambda.max, the (data derived) entry value (i.e. the smallest value for which all coefficients are zero); the default is 0.01.}

\item{thol}{stopping precision for the coordinate-descent algorithm; the default value is 1e-5.}

\item{max.ite}{number of maximum iterations; the default value is 1e5.}

\item{regfunc}{type of the regularizer; the default is "L1"; can also be "MCP" or "SCAD".}

\item{row.ordering}{a particular ordering (n-by-1 vector) of the rows (provided by the user) to be used for cross-validation; the default is \code{NULL} in which case the row order is randomly shuffled.}

\item{cv1sd}{if \code{TRUE}, an optimal regularization parameter is chosen based on: the mean cross-validated error + 1 SD of the mean cross-validated error, which typically results in an increase in regularization; the defualt is \code{FALSE}.}

\item{terms.fit}{if \code{TRUE}, in \code{samTEMsel}, compute and store the component-wise fitted vectors (y.hat.list) and partial residuals (resid.list), which are evaluated over a grid of \code{lambda}.}

\item{plots}{if \code{TRUE}, produce a cross-validation plot of the estimated mean squared error versus the regulariation parameter index.}

\item{lambda}{a user-supplied regularization parameter sequence; typical usage is to have the program compute its own lambda sequence based on nlambda and lambda.min.ratio.}
}
\value{
a list of information of the fitted constrained sparse additive model including
 \item{samTEMsel.obj}{an object of class \code{samTEMsel}, which contains the sequence of the fitted constrained additive models implied by the sequence of the regularization parameters \code{lambda}; see \code{samTEMsel} for detail.}
 \item{lambda.opt.index}{an index number, indicating the index of the estimated optimal regularization parameter in \code{lambda}.}
 \item{nonzero.index}{a set of numbers, indicating the indices of estimated nonzero component functions, evalated at the regularization parameter index \code{lambda.opt.index}.}
 \item{func_norm.opt}{a p-by-1 vector, indicating the norms of the estimated component functions evaluatd at the regularization parameter index \code{lambda.opt.index}, with each element corresponding to the norm of each estimated component function.}
 \item{cv.storage}{a n.folds-by-nlambda matrix of the estimated mean squared errors, with each column corresponding to each of the regularization parameters in \code{lambda} and each row corresponding to each of the n.folds folds.}
 \item{mean.cv}{a nlambda-by-1 vector of the estimated mean squared errors, with each element corresponding to each of the regularization parameters in \code{lambda}.}
 \item{sd.cv}{a nlambda-by-1 vector of the standard deviation of the estimated mean squared errors, with each element corresponding to each of the regularization parameters in \code{lambda}.}
}
\description{
Does k-fold cross-validation for \code{samTEMsel}, produces a plot, and returns the sequence of the fitted constrained additive models implied by the sequence of regularization parameters \code{lambda} and the index, \code{lambda.opt.index}, corresponding to the estimated optimal regularization parameter.
}
\examples{
set.seed(112)
n.train = 300
n.test  = 1000
n = n.train + n.test
p = 50
A = rbinom(n, 1, 0.5) + 1  # treatment variable taking a value in {1,2} with equal prob.
X = matrix(runif(n*p, -pi/2,pi/2), n, p)  # pretreatment covariates
noise = rnorm(n, 0, 0.5)
# X main effect on y; a highly nonlinear (cosine) function; depends on the first 10 covariates
main.effect = rep(0, n); for(j in 1:10){
  main.effect = main.effect + cos(X[,j])
}
# A-by-X ineraction effect on y; depends only on X1 and X2.
interaction.effect = (A-1.5)*X[,1]  +  2 * (A-1.5)*(cos(X[,2]) - 0.5)
# generate outcome y
y = main.effect  + interaction.effect + noise


# train/test set splitting
train.index = 1:n.train
y.train = y[train.index]
X.train = X[train.index,]
A.train = A[train.index]
y.test  = y[-train.index]
X.test  = X[-train.index,]
A.test  = A[-train.index]


# obtain an optimal regularization parameter by running cv.samTEMsel().
cv.obj = cv.samTEMsel(y.train, A.train, X.train, nlambda = 100)

samTEMsel.obj = cv.obj$samTEMsel.obj
# samTEMsel.obj contains the sequence of fitted models over the grid of lambda
# see also, samTEMsel().

# lambda.opt.index corresponds to the optimal regularization parameter chosen from cv.samTEMsel().
lambda.opt.index = cv.obj$lambda.opt.index
lambda.opt.index

# plot the estimated component function of variable (j=)2, say.
plot_samTEMsel(samTEMsel.obj,  which.index = 2, lambda.index = lambda.opt.index)

# make ITRs for subjects with pretreatment characteristics, X.test
trt.rule = make_ITR(samTEMsel.obj, newX = X.test, lambda.index = lambda.opt.index)$trt.rule
head(trt.rule)

# an (IPWE) estimate of the "value" of this particualr treatment rule, trt.rule:
mean(y.test[A.test==trt.rule])

# compare the above value to the following estimated "values" of "naive" treatment rules:
mean(y.test[A.test==1])   # a rule that assigns everyone to A=1
mean(y.test[A.test==2])   # a rule that assigns everyone to A=2

}
\seealso{
\code{samTEMsel}, \code{predict_samTEMsel}, \code{plot_samTEMsel}
}
\author{
Park, Petkova, Tarpey, Ogden
}
